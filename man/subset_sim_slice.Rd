% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/subset_sim_slice.R
\name{subset_sim_slice}
\alias{subset_sim_slice}
\title{Perform subset simulation with slice sampling}
\usage{
subset_sim_slice(
  implausibility,
  dims,
  target_levels = 3,
  control_list = list()
)
}
\arguments{
\item{implausibility}{A function that takes a vector of length \code{dims} as the first argument
and computes the function for which there is a level set target. Output is a single value or vector of values the same length as the length of \code{target_levels}}

\item{dims}{Integer. The dimensionality of the parameter space.}

\item{target_levels}{Numeric vector. A vector of implausibility levels describing the cutoff for each wave.
A vector of length 1 indicates a single wave and could be used to indicate a single level set of a function.}

\item{control_list}{List. A list of control parameters with the following elements:
\itemize{
\item \code{num_switches}: Integer. Number of switch inputs (default: 0).
\item \code{volume_ratio}: Numeric. Volume ratio for slice sampling (default: 0.1).
\item \code{num_mutations}: Integer. Number of mutations per chain (default: 30).
\item \code{num_iterations}: Integer. Number of iterations for the final sampling wave (default: 1000).
\item \code{box_limits}: Numeric matrix (dims x 2). Bounds for the initial space.
\item \code{switch_settings_list}: List of length \code{num_switches} containing the possible values for each switch input (default: NULL).
\item \code{debug_mode}: Logical. Enable debug messages (default: FALSE).
\item \code{max_num_chains}: Integer. Maximum number of chains (default: 8).
\item \code{levels_dp}: Integer. Decimal places for implausibility levels (default: 2).
\item \code{one_per_level}: Logical. Whether to generate a single chain targeting each value of \code{target_levels} separately (default: FALSE).
}}
}
\value{
A list containing:
\itemize{
\item \code{x}: Numeric matrix. Uniform samples from the final sampling wave.
\item \code{implausibilities}: Numeric vector or matrix. Implausibility values associated with the samples.
\item \code{reached_target}: Logical. Whether the target implausibility levels were reached.
}
}
\description{
This function initializes and performs Markov Chain Monte Carlo (MCMC) sampling using a
subset simulation approach to identify implausibility levels and generate samples.
}
\details{
This function is very effective if confident that the target space is simply connected. If not, and one or more disconnected regions is suspected, the \code{subset_sim_slice_partitioned} function will enable additional regions to be found if using a number of partitions. If used on a simply connected region, this function will return uniform samples.
}
\examples{
# Example usage
st1 = rbind(c(0.000002, 0.000000875), c(0.000000875, 0.00025))
st2 = rbind(c(0.00005, 0.000000825), c(0.000000825, 0.000002))
sdtiny <- function(x, m1 = c(0, 0), m2 = c(5, 4),
                   s1 = st1, s2 = st2) {
  coef1 <- (1 / ((s1[2, 2] * s1[1, 1]) - (s1[2, 1] * s1[1, 2])))
  s1inv <- coef1 * rbind(c(s1[2, 2], -s1[1, 2]), c(-s1[2, 1], s1[1, 1]))
  coef2 <- (1 / ((s2[2, 2] * s2[1, 1]) - (s2[2, 1] * s2[1, 2])))
  s2inv <- coef2 * rbind(c(s2[2, 2], -s2[1, 2]), c(-s2[2, 1], s2[1, 1]))
  sdevs1 <- sqrt(t(x - m1) \%*\% s1inv \%*\% (x - m1))
  sdevs2 <- sqrt(t(x - m2) \%*\% s2inv \%*\% (x - m2))
  min(sdevs1, sdevs2)
}
implausibility <- function(x, target_level = 3) {
  sdtiny(x)
}
control_list <- list(
  box_limits = cbind(rep(-3, 2), rep(7, 2)),
  num_mutations = 40,
  num_iterations = 100
)
result <- subset_sim_slice(
  implausibility,
  dims = 2,
  target_levels = 3,
  control_list = control_list
)
}
