% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/construct_temperature_ladder.R
\name{construct_temperature_ladder}
\alias{construct_temperature_ladder}
\title{Construct Temperature Ladder for Parallel Tempering MCMC}
\usage{
construct_temperature_ladder(
  implausibility,
  dims,
  target_levels,
  control_list = list()
)
}
\arguments{
\item{implausibility}{A function that takes a vector of length \code{dims} as the first argument
and computes the function for which there is a level set target. Output is a single value or vector of values the same length as the length of \code{target_levels}.}

\item{dims}{Integer. Dimensionality of the parameter space.}

\item{target_levels}{Numeric vector. A vector of implausibility levels describing the cutoff for each wave.
A vector of length 1 indicates a single wave and could be used to indicate a single level set of a function.}

\item{control_list}{List. A list of control parameters with defaults:
\describe{
\item{\code{num_switches}}{Integer. Number of switch variables in the model. Default: 0.}
\item{\code{volume_ratio}}{Numeric. Ratio for volume-based thresholding. Increase to improve mixing between chains and decrease to use fewer chains to find the target space. Default: 0.1.}
\item{\code{num_mutations}}{Integer. Number of iterations (often called mutations in the Evolutionary Monte Carlo literature) for individual chains within the parallel structure. Default: 30.}
\item{\code{num_iterations}}{Integer. Number of iterations of the paralel chains. Default: 1000.}
\item{\code{box_limits}}{Matrix. A \code{dims x 2} matrix specifying the lower and upper bounds of the initial space.}
\item{\code{switch_settings_list}}{List. A list of length num_switches, each element containing a vector of the possible settings of each switch. Defaults to NULL}
\item{\code{levels_dp}}{Integer. Number of decimal places for implausibility levels. Default: 2.}
\item{\code{one_per_level}}{Logical. If \code{TRUE}, ensures unique implausibility levels for each wave. Default: \code{FALSE}.}
\item{\code{print_every}}{Integer. Frequency of progress updates during sampling to generate new temperature levels. Default: 100.}
}}
}
\value{
A list with:
\itemize{
\item \code{imp_levels}: List of temperature/implausibility levels for each wave.
\item \code{x_starts}: Matrix of starting values for the chains.
\item \code{control_list}: Updated control list with additional elements used during sampling.
}
}
\description{
This function initializes the full Markov Chain (parallel chains) using
slice sampling and parallel tempering. The temperature ladder is constructed iteratively
by finding implausibility levels for each wave that ensure good mixing.
}
\details{
Currently no stopping rule exists for this, though the printing is sufficiently verbose for the user to understand what is happening. If a target compatible subspace exists, this algorithm will find it eventually, however, if the ladder seems to be converging far above the target, it may be worth the user intervening.
}
\examples{
# Example usage
st1 <- rbind(c(0.000002, 0.000000875), c(0.000000875, 0.00025))
st2 <- rbind(c(0.00005, 0.000000825), c(0.000000825, 0.000002))
sdtiny <- function(x, m1=c(0,0), m2=c(5,4),
                   s1=st1, s2=st2) {
  coef1 <- (1 / ((s1[2, 2] * s1[1, 1]) - (s1[2, 1] * s1[1, 2])))
  s1inv <- coef1 * rbind(c(s1[2, 2], -s1[1, 2]), c(-s1[2, 1], s1[1, 1]))
  coef2 <- (1 / ((s2[2, 2] * s2[1, 1]) - (s2[2, 1] * s2[1, 2])))
  s2inv <- coef2 * rbind(c(s2[2, 2], -s2[1, 2]), c(-s2[2, 1], s2[1, 1]))
  sdevs1 <- sqrt(t(x - m1) \%*\% s1inv \%*\% (x - m1))
  sdevs2 <- sqrt(t(x - m2) \%*\% s2inv \%*\% (x - m2))
  return(min(sdevs1, sdevs2))
}
implausibility <- function(x, target_level=3) {
  sdtiny(x)
}
control_list <- list(
  box_limits = cbind(rep(-3, 2), rep(7, 2)),
  num_mutations = 8,
  num_iterations = 100
)
new_ladder <- construct_temperature_ladder(
  implausibility = implausibility,
  dims = 2,
  target_levels = 3,
  control_list = control_list
)

# Example with multiple levels of implausibility (e.g., from multiple waves of history matching)
ss1 <- rbind(c(0.0002, 0.0000875), c(0.0000875, 0.0025))
ss2 <- rbind(c(0.005, 0.0000825), c(0.0000825, 0.0002))
sdsmall <- function(x, m1=c(0,0), m2=c(5,4),
                    s1=ss1, s2=ss2) {
  coef1 <- (1 / ((s1[2, 2] * s1[1, 1]) - (s1[2, 1] * s1[1, 2])))
  s1inv <- coef1 * rbind(c(s1[2, 2], -s1[1, 2]), c(-s1[2, 1], s1[1, 1]))
  coef2 <- (1 / ((s2[2, 2] * s2[1, 1]) - (s2[2, 1] * s2[1, 2])))
  s2inv <- coef2 * rbind(c(s2[2, 2], -s2[1, 2]), c(-s2[2, 1], s2[1, 1]))
  sdevs1 <- sqrt(t(x - m1) \%*\% s1inv \%*\% (x - m1))
  sdevs2 <- sqrt(t(x - m2) \%*\% s2inv \%*\% (x - m2))
  return(min(sdevs1, sdevs2))
}
sb1 <- rbind(c(0.002, 0.000875), c(0.000875, 0.025))
sb2 <- rbind(c(0.05, 0.000825), c(0.000825, 0.002))
sdbig <- function(x, m1=c(0,0), m2=c(5,4),
                  s1=sb1, s2=sb2) {
  coef1 <- (1 / ((s1[2, 2] * s1[1, 1]) - (s1[2, 1] * s1[1, 2])))
  s1inv <- coef1 * rbind(c(s1[2, 2], -s1[1, 2]), c(-s1[2, 1], s1[1, 1]))
  coef2 <- (1 / ((s2[2, 2] * s2[1, 1]) - (s2[2, 1] * s2[1, 2])))
  s2inv <- coef2 * rbind(c(s2[2, 2], -s2[1, 2]), c(-s2[2, 1], s2[1, 1]))
  sdevs1 <- sqrt(t(x - m1) \%*\% s1inv \%*\% (x - m1))
  sdevs2 <- sqrt(t(x - m2) \%*\% s2inv \%*\% (x - m2))
  return(min(sdevs1, sdevs2))
}
implausibility <- function(x, targetLevel, levels=5, waves=3) {
  ans <- rep(Inf, levels)
  waveFail <- FALSE
  this.level <- 1
  wave.num <- 1
  Timp <- NA
  while ((this.level <= levels) & !waveFail) {
    if (wave.num == 1) {
      Timp <- sdbig(x)
    } else if (wave.num == 2) {
      Timp <- sdsmall(x)
    } else {
      Timp <- sdtiny(x)
    }
    wave.num <- wave.num + 1
    if ((Timp > targetLevel[this.level]) & (wave.num <= waves)) {
      waveFail <- TRUE
    }
    if ((!waveFail) & (wave.num > waves)) {
      ans[this.level:levels] <- Timp
      this.level <- levels + 1
    } else {
      ans[this.level] <- Timp
      this.level <- this.level + 1
    }
  }
  return(ans)
}
control_list <- list(
  num_mutations = 8,
  num_iterations = 100,
  box_limits = cbind(rep(-3, 2), rep(7, 2))
)
new_ladder <- construct_temperature_ladder(
  implausibility = implausibility,
  dims = 2,
  target_levels = c(3, 3, 3, 2.5, 2),
  control_list = control_list
)
}
